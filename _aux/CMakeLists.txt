cmake_minimum_required( VERSION 2.6 )
if ( NOT CMAKE_BUILD_TYPE )
	set( CMAKE_BUILD_TYPE debug CACHE STRING "Choose the type of build, options are: debug, release." FORCE )
endif ( NOT CMAKE_BUILD_TYPE )
if ( ( NOT ( "${CMAKE_BUILD_TYPE}" STREQUAL "debug" ) ) AND ( NOT ( "${CMAKE_BUILD_TYPE}" STREQUAL "release" ) ) )
	message( FATAL_ERROR "Only `debug' and `release' tergets are supported." )
endif ( ( NOT ( "${CMAKE_BUILD_TYPE}" STREQUAL "debug" ) ) AND ( NOT ( "${CMAKE_BUILD_TYPE}" STREQUAL "release" ) ) )

if ( "${CMAKE_BUILD_TYPE}" STREQUAL "debug" )
	message( "Generating debug build." )
	set( LIB_INFIX "-d" )
else ( "${CMAKE_BUILD_TYPE}" STREQUAL "release" )
	message( "Generating release build." )
	set( LIB_INFIX "" )
endif ( "${CMAKE_BUILD_TYPE}" STREQUAL "debug" )

#set( CMAKE_VERBOSE_MAKEFILE true )
enable_language( C )
project( yaal CXX )
set( COMPONENTS hcore tools dbwrapper hconsole hdata )
get_filename_component( yaal_SOURCE_DIR ${yaal_SOURCE_DIR}/../ ABSOLUTE )
message( "yaal_SOURCE_DIR: " ${yaal_SOURCE_DIR} )
include_directories( "${yaal_SOURCE_DIR}" )
add_definitions( -D__YAAL_BUILD__ -D__ID__="" -D__TID__="" )
if ( CMAKE_HOST_WIN32 )
	set( LIB_PREFIX "" )
	set( LIB_EXT "dll" )
	set( SYMBOL_PREFIX "" )
else ( CMAKE_HOST_WIN32 )
	set( LIB_PREFIX "lib" )
	set( LIB_EXT "so" )
	set( SYMBOL_PREFIX "" )
endif ( CMAKE_HOST_WIN32 )
include( CheckFunctionExists )
check_function_exists( strcasestr HAVE_STRCASESTR )
check_function_exists( asprintf HAVE_ASPRINTF )
check_function_exists( strtold HAVE_STRTOLD )
check_function_exists( gethostbyname_r HAVE_GETHOSTBYNAME_R )
check_function_exists( memrchr HAVE_MEMRCHR )
include( CheckSymbolExists )
set( CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE )
check_symbol_exists( TEMP_FAILURE_RETRY unistd.h HAVE_DECL_TEMP_FAILURE_RETRY )
check_symbol_exists( getaddrinfo  netdb.h;netinet/in.h;sys/socket.h HAVE_DECL_GETADDRINFO )
check_symbol_exists( SUN_LEN sys/un.h HAVE_DECL_SUN_LEN )
set( CMAKE_REQUIRED_DEFINITIONS )
include( CheckIncludeFileCXX )
check_include_file_cxx( sqlite3.h HAVE_SQLITE3_H )
if ( HAVE_SQLITE3_H )
	list( APPEND DRIVERS sqlite3 )
endif ( HAVE_SQLITE3_H )
check_include_file_cxx( postgresql/libpq-fe.h HAVE_POSTGRESQL_LIBPQ_FE_H )
check_include_file_cxx( libpq-fe.h HAVE_LIBPQ_FE_H )
if ( HAVE_LIBPQ_FE_H OR HAVE_POSTGRESQL_LIBPQ_FE_H )
	list( APPEND DRIVERS postgresql )
endif ( HAVE_LIBPQ_FE_H OR HAVE_POSTGRESQL_LIBPQ_FE_H )
check_include_file_cxx( mysql/mysql.h HAVE_MYSQL_MYSQL_H )
if ( HAVE_MYSQL_MYSQL_H )
	list( APPEND DRIVERS mysql )
endif ( HAVE_MYSQL_MYSQL_H )
check_include_file_cxx( oci.h HAVE_OCI_H )
if ( HAVE_OCI_H )
	list( APPEND DRIVERS oracle )
endif ( HAVE_OCI_H )
find_package( Threads REQUIRED )
find_package( LibXml2 REQUIRED )
set_property( DIRECTORY APPEND PROPERTY INCLUDE_DIRECTORIES /usr/include/libxml2 )
find_package( LibXslt REQUIRED )
find_package( OpenSSL REQUIRED )
find_package( Curses REQUIRED )
check_include_file_cxx( execinfo.h HAVE_EXECINFO_H )
check_include_file_cxx( sys/consio.h HAVE_SYS_CONSIO_H )
check_include_file_cxx( gpm.h HAVE_GPM_H )
check_include_file_cxx( ncurses/curses.h HAVE_NCURSES_CURSES_H )
check_include_file_cxx( curses.h HAVE_CURSES_H )
if ( HAVE_NCURSES_CURSES_H )
	set( CURSES_PATH "ncurses/curses.h" )
else ( HAVE_NCURSES_CURSES_H )
	set( CURSES_PATH "curses.h" )
endif ( HAVE_NCURSES_CURSES_H )
include( CheckCXXSourceCompiles )
check_cxx_source_compiles("#include<cmath>
	int main( int, char** ) { ::powl( 0., 0. ); return ( 0 ); }" HAVE_POWL )
check_cxx_source_compiles("#include<cmath>
	int main( int, char** ) { ::floorl( 0. ); return ( 0 ); }" HAVE_DECL_FLOORL )
check_cxx_source_compiles("#include<netdb.h>
#define NULL	0
int main( int, char const* const* const )
	{
	int i = 0;
	char* p = NULL;
	struct hostent h, * ph = NULL;
	::gethostbyname_r( \"\", &h, p, 0, &ph, &i );
	return ( 0 );
	}" HAVE_GNU_GETHOSTBYNAME_R )
if ( CMAKE_HOST_WIN32 )
	set_property( DIRECTORY APPEND PROPERTY INCLUDE_DIRECTORIES $ENV{CMAKE_INCLUDE_PATH} )
	set( NCURSES_ATTR_GET_SECOND_ARG_TYPE_int 1 )
else ( CMAKE_HOST_WIN32 )
	set( CMAKE_REQUIRED_LIBRARIES ${CURSES_LIBRARIES} )
	set( CMAKE_REQUIRED_FLAGS "-Wall -Werror -Wcast-align -Wconversion -Wwrite-strings -pedantic-errors -Wcast-qual" )
	check_cxx_source_compiles("#include <${CURSES_PATH}>
		int main( int, char** ){ attr_t* a( NULL ); int short* p( NULL ); attr_get( a, p, NULL ); return( 0 ); }" NCURSES_ATTR_GET_SECOND_ARG_TYPE_int_short)
	check_cxx_source_compiles("#include <${CURSES_PATH}>
		int main( int, char** ){ attr_t* a( NULL ); int* p( NULL ); attr_get( a, p, NULL ); return( 0 ); }" NCURSES_ATTR_GET_SECOND_ARG_TYPE_int)
	set( CMAKE_REQUIRED_FLAGS )
	set( CMAKE_REQUIRED_LIBRARIES )
endif ( CMAKE_HOST_WIN32 )
if ( NCURSES_ATTR_GET_SECOND_ARG_TYPE_int_short )
	set( NCURSES_ATTR_GET_SECOND_ARG_TYPE "int short" )
elseif ( NCURSES_ATTR_GET_SECOND_ARG_TYPE_int  )
	set( NCURSES_ATTR_GET_SECOND_ARG_TYPE "int" )
else ( NCURSES_ATTR_GET_SECOND_ARG_TYPE_int )
	message( FATAL_ERROR "Unknown type for second argument of attr_get in ncurses library!")
endif ( NCURSES_ATTR_GET_SECOND_ARG_TYPE_int_short )
configure_file( ${yaal_SOURCE_DIR}/_aux/config.hxx.cmake config.hxx )

macro( yaal_make_component name )
	message( "Processing component: " ${name} )
	file( GLOB SRCS ${yaal_SOURCE_DIR}/${name}/*.cxx )
	file( GLOB HDRS ${yaal_SOURCE_DIR}/${name}/*.hxx )
	file( GLOB DRIVER ${yaal_SOURCE_DIR}/${name}/*_driver.cxx )
	list( REMOVE_ITEM SRCS ${DRIVER} dummy_item )
	add_library( ${name}${LIB_INFIX} SHARED ${SRCS} ${HDRS} )
	set_target_properties( ${name}${LIB_INFIX} PROPERTIES LINKER_LANGUAGE CXX LIBRARY_OUTPUT_DIRECTORY build/${CMAKE_BUILD_TYPE} )
endmacro( yaal_make_component )

macro( yaal_make_driver name )
	message( "Processing driver: " ${name} )
	add_library( ${name}_driver${LIB_INFIX} SHARED dbwrapper/${name}_driver.cxx )
	set_target_properties( ${name}_driver${LIB_INFIX} PROPERTIES LINKER_LANGUAGE CXX LIBRARY_OUTPUT_DIRECTORY build/${CMAKE_BUILD_TYPE} )
endmacro( yaal_make_driver )

foreach( COMPONENT ${COMPONENTS} )
	yaal_make_component( "${COMPONENT}" )
endforeach( COMPONENT )

foreach( DRIVER ${DRIVERS} )
	yaal_make_driver( "${DRIVER}" )
endforeach( DRIVER )

