/* Read yaal/LICENSE.md file for copyright and licensing information. */

#include "hcore/base.hxx"
M_VCSID( "$Id: " __ID__ " $" )
M_VCSID( "$Id: " __TID__ " $" )
#include "randomizer.hxx"
#include "runtime.hxx"
#include "helper.hxx"
#include "thread.hxx"
#include "objectfactory.hxx"
#include "instruction.hxx"

using namespace yaal;
using namespace yaal::hcore;
using namespace yaal::tools::huginn;

namespace yaal {

namespace tools {

namespace huginn {

class HRandomizerClass : public HHuginn::HClass {
public:
	typedef HRandomizerClass this_type;
	typedef HHuginn::HClass base_type;
private:
	enumeration::HEnumerationClass::ptr_t _distributionEnumerationClass;
	HHuginn::class_t _exceptionClass;
public:
	HRandomizerClass( HRuntime* runtime_, HHuginn::type_id_t typeId_, HHuginn::identifier_id_t identifierId_, HHuginn::HClass const* origin_ )
		: HClass(
			runtime_,
			typeId_,
			identifierId_,
			"The `Randomizer` class represents a random number generator concept. `Randomizer` can generate uniform distribution of either `integer` or `real` values from given range.",
			HHuginn::ACCESS::PUBLIC,
			HHuginn::HClass::TYPE::BUILTIN,
			origin_,
			&HRandomizer::create_instance
		)
		, _distributionEnumerationClass()
		, _exceptionClass() {
		HHuginn::field_definitions_t fd{
			{ "next",      runtime_->create_method( &HRandomizer::next ),      "get next random number from this distribution" },
			{ "seed",      runtime_->create_method( &HRandomizer::seed ),      "([ *data* ]) - initialize random generator internal state based on supplied *data*, or using system entropy if no data is given" },
			{ "to_string", runtime_->create_method( &HRandomizer::to_string ), "get string representation of this `Randomizer`" }
		};
		redefine( nullptr, fd );
		_distributionEnumerationClass = add_enumeration_as_member(
			this,
			enumeration::create_class(
				runtime_,
				"DISTRIBUTION",
				enumeration::descriptions_t{
					{ "DISCRETE", "an uniform discrete distribution of `integer` values, parametrized by [a, b]",     static_cast<int>( HRandomizer::DISTRIBUTION::DISCRETE ) },
					{ "UNIFORM",  "an uniform continuous distribution of `real` values, parametrized by [a, b]",      static_cast<int>( HRandomizer::DISTRIBUTION::UNIFORM ) },
					{ "TRIANGLE", "a triangle continuous distribution of `real` values, parametrized by [a, b, mod]", static_cast<int>( HRandomizer::DISTRIBUTION::TRIANGLE ) },
					{ "NORMAL",   "a normal (Gaussian) distribution of `real` values, parametrized by [mu, sigma]",   static_cast<int>( HRandomizer::DISTRIBUTION::NORMAL ) }
				},
				"The `DISTRIBUTION` is set of possible random variable distributions generated by a `Randomizer`.",
				HHuginn::VISIBILITY::PACKAGE,
				this
			),
			"set of available distributions used for Randomizer.",
			HHuginn::HClass::MEMBER_TYPE::STATIC
		);
	}
	HHuginn::HClass const* distribution_class( void ) const {
		return ( _distributionEnumerationClass->enumeral_class() );
	}
};

HRandomizer::HRandomizer( HHuginn::HClass const* class_, yaal::i64_t cap_ )
	: HValue( class_ )
	, _generator( random::rng_helper::make_random_number_generator( cap_ ) ) {
	return;
}

HRandomizer::HRandomizer( HHuginn::HClass const* class_, yaal::random::distribution::HDiscrete const& generator_ )
	: HValue( class_ )
	, _generator( generator_ ) {
	return;
}

HHuginn::value_t HRandomizer::create_instance( HHuginn::HClass const* class_, huginn::HThread* thread_, HHuginn::values_t& values_, int position_ ) {
	M_PROLOG
	char const name[] = "Randomizer.constructor";
	verify_arg_count( name, values_, 0, 1, thread_, position_ );
	yaal::i64_t cap( meta::max_signed<yaal::i64_t>::value );
	if ( ! values_.is_empty() ) {
		verify_arg_type( name, values_, 0, HHuginn::TYPE::INTEGER, ARITY::UNARY, thread_, position_ );
		cap = get_integer( values_[0] );
	}
	return ( thread_->object_factory().create<huginn::HRandomizer>( class_, cap ) );
	M_EPILOG
}

HHuginn::value_t HRandomizer::seed( huginn::HThread* thread_, HHuginn::value_t* object_, HHuginn::values_t& values_, int position_ ) {
	M_PROLOG
	char const name[] = "Randomizer.seed";
	verify_arg_count( name, values_, 0, 1, thread_, position_ );
	HRandomizer* o( static_cast<HRandomizer*>( object_->raw() ) );
	if ( ! values_.is_empty() ) {
		verify_arg_type( name, values_, 0, HHuginn::TYPE::INTEGER, ARITY::UNARY, thread_, position_ );
		yaal::u64_t data( static_cast<yaal::u64_t>( get_integer( values_[0] ) ) );
		o->_generator.set_seed( data );
	} else {
		o->_generator = random::rng_helper::make_random_number_generator( static_cast<yaal::i64_t>( o->_generator.range() ) );
	}
	return ( *object_ );
	M_EPILOG
}

HHuginn::value_t HRandomizer::next( huginn::HThread* thread_, HHuginn::value_t* object_, HHuginn::values_t& values_, int position_ ) {
	M_PROLOG
	char const name[] = "Randomizer.next";
	verify_arg_count( name, values_, 0, 1, thread_, position_ );
	yaal::u64_t cap( 0 );
	if ( ! values_.is_empty() ) {
		verify_arg_type( name, values_, 0, HHuginn::TYPE::INTEGER, ARITY::UNARY, thread_, position_ );
		cap = static_cast<yaal::u64_t>( get_integer( values_[0] ) );
	}
	HRandomizer* o( static_cast<HRandomizer*>( object_->raw() ) );
	return ( thread_->object_factory().create_integer( cap ? static_cast<HHuginn::HInteger::value_type>( static_cast<u64_t>( o->_generator() ) % cap ) : o->_generator() ) );
	M_EPILOG
}

HHuginn::value_t HRandomizer::to_string( huginn::HThread* thread_, HHuginn::value_t* object_, HHuginn::values_t& values_, int position_ ) {
	M_PROLOG
	char const name[] = "Randomizer.to_string";
	verify_arg_count( name, values_, 0, 0, thread_, position_ );
	HRandomizer* o( static_cast<HRandomizer*>( object_->raw() ) );
	HHuginn::HClass const* origin( o->HValue::get_class()->origin() );
	HString s;
	if ( origin ) {
		s.append( thread_->runtime().package_name( origin ) ).append( "." );
	}
	s.append( "Randomizer(" );
	yaal::u64_t cap( o->_generator.range() );
	if ( cap != meta::max_unsigned<yaal::u64_t>::value ) {
		s.append( cap );
	}
	s.append( ")" );
	return ( thread_->runtime().object_factory()->create_string( yaal::move( s ) ) );
	M_EPILOG
}

HHuginn::class_t HRandomizer::get_class( HRuntime* runtime_, HHuginn::HClass const* origin_ ) {
	M_PROLOG
	HHuginn::identifier_id_t classIdentifier( runtime_->identifier_id( "Randomizer" ) );
	HHuginn::class_t c( runtime_->get_class( classIdentifier ) );
	if ( ! c ) {
		c = runtime_->create_class(
			HRuntime::class_constructor_t(
				[&runtime_, &classIdentifier, &origin_] ( HHuginn::type_id_t typeId_ ) -> HHuginn::class_t {
					return (
						make_pointer<HRandomizerClass>(
							runtime_,
							typeId_,
							classIdentifier,
							origin_
						)
					);
				}
			)
		);
		runtime_->huginn()->register_class( c, HHuginn::VISIBILITY::GLOBAL );
	}
	return ( c );
	M_EPILOG
}

HHuginn::value_t HRandomizer::do_clone( huginn::HThread* thread_, HHuginn::value_t*, int ) const {
	return ( thread_->object_factory().create<HRandomizer>( HValue::get_class(), _generator ) );
}

}

}

}
